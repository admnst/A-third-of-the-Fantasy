<!DOCTYPE html>
<html lang="zn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no,user-scalable=no">
    <link rel="icon" href="favicon.ico" sizes="32x32">
    <title>方圆</title>
</head>

<body>
    <!-- <div id="pixi_div"></div> -->
    <canvas id="pixi_canvas"></canvas>
    <pre id="log" style="border: 1px solid #ccc;display:none;"></pre>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
    </style>
    <script src="static/js/pixi.min.js"></script>
    <script type="text/javascript">
        var pixi_div = document.getElementById('pixi_canvas');
        var app = new PIXI.Application(window.innerWidth, window.innerHeight - 4, {
            backgroundColor: 0x1099bb,
            antialias: true,
            resolution: 1,
            view: pixi_div
        });
        // pixi_div.appendChild(app.view);
        var stage = new PIXI.Container();
        app.stage.interactive = true;

        var graphics = new PIXI.Graphics();
        var _width = (window.innerWidth >= (window.innerHeight / 2) ? window.innerHeight / 2 : window.innerWidth);

        // 画圆1
        var circle_site1 = {
            x: _width / 2,
            y: _width / 2,
            r: _width * 18 / 24 / 2,
        }
        // 画圆2
        var circle_site2 = {
            x: _width / 2,
            y: _width / 2,
            r: _width * 18 / 24 / 2 - 30,
        }
        var r = _width * 18 / 24 / 2;
        graphics.lineStyle(0);
        graphics.beginFill(0xffd900);
        graphics.drawCircle(circle_site1.x, circle_site1.y, circle_site1.r);
        graphics.endFill();

        graphics.lineStyle(0);
        graphics.beginFill(0x1099bb);
        graphics.drawCircle(circle_site2.x, circle_site2.y, circle_site2.r);
        graphics.endFill();

        var refresh = new PIXI.Graphics();
        refresh.lineStyle(0);
        refresh.beginFill(0x0d90b0);
        refresh.drawRect(_width - 10, 10, 24, 24);
        refresh.endFill();
        refresh.on('click', onClick);
        var style = {
            fontSize: '24px',
            fill: '#fff',
            stroke: '#4a1850',
        };
        var basicText = new PIXI.Text('刷新', style);
        basicText.x = _width - 10;
        basicText.y = 10;
        // refresh.addChild(basicText);
        app.stage.addChild(refresh);
        function onClick() {
            alert(2);
        }

        var spuare_site1 = {
            x1: _width / 6,
            x2: _width * 5 / 6,
            y1: _width / 6 + _width,
            y2: _width * 5 / 6 + _width,
        }
        var spuare_site2 = {
            x1: _width / 6 + 30,
            x2: _width * 5 / 6 - 30,
            y1: _width / 6 + _width + 30,
            y2: _width * 5 / 6 + _width - 30,
        }

        graphics.beginFill(0xffd900);
        graphics.lineStyle(0);
        // 画方1
        graphics.moveTo(spuare_site1.x1, spuare_site1.y1);
        graphics.lineTo(spuare_site1.x2, spuare_site1.y1);
        graphics.lineTo(spuare_site1.x2, spuare_site1.y2);
        graphics.lineTo(spuare_site1.x1, spuare_site1.y2);
        graphics.lineTo(spuare_site1.x1, spuare_site1.y1);
        graphics.endFill();
        // 画方2
        graphics.lineStyle(0);
        graphics.beginFill(0x1099bb);
        graphics.moveTo(spuare_site2.x1, spuare_site2.y1);
        graphics.lineTo(spuare_site2.x2, spuare_site2.y1);
        graphics.lineTo(spuare_site2.x2, spuare_site2.y2);
        graphics.lineTo(spuare_site2.x1, spuare_site2.y2);
        graphics.lineTo(spuare_site2.x1, spuare_site2.y1);
        graphics.endFill();

        var color = 0x3A5FCD;

        graphics.beginFill();
        graphics.lineStyle(5, color);

        app.stage.addChild(graphics);

        var ongoingTouches = new Array(); //用来保存跟踪正在发送的触摸事件
        var mark = ['+', '-', '*', '/'];
        //设置事件处理程序
        var is_mousedown = 0;
        pixi_div.addEventListener("mousedown", function () { is_mousedown = 1; }, false);
        pixi_div.addEventListener("mousemove", function (e) {
            if (is_mousedown) {
                graphics.moveTo(e.clientX, e.clientY);
                graphics.lineTo(e.clientX + 1, e.clientY + 1);
                inline_function(touches[i].pageX, touches[i].pageY)
            }
        }, false);
        pixi_div.addEventListener("mouseup", function () { is_mousedown = 0; }, false);
        pixi_div.addEventListener("touchstart", handleStart, false);
        pixi_div.addEventListener("touchend", handleEnd, false);
        pixi_div.addEventListener("touchcancel", handleCancel, false);
        pixi_div.addEventListener("touchleave", handleEnd, false);
        pixi_div.addEventListener("touchmove", handleMove, false);
        log("\ninitialized.");
        //处理触摸开始事件
        function handleStart(evt) {
            evt.preventDefault(); //阻止事件的默认行为
            var touches = evt.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                log("\ntouchstart:" + mark[i] + "...");
                ongoingTouches.push(copyTouch(touches[i]));
            }
        }
        //处理触摸移动事件
        function handleMove(evt) {
            evt.preventDefault();
            var touches = evt.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                var idx = ongoingTouchIndexById(touches[i].identifier);
                if (idx >= 0) {
                    log(mark[idx], 1);
                    graphics.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
                    graphics.lineTo(touches[i].pageX, touches[i].pageY);
                    inline_function(touches[i].pageX, touches[i].pageY)
                    ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
                } else {
                    log("can't figure out which touch to continue");
                }
            }
        }
        //处理触摸结束事件
        function handleEnd(evt) {
            evt.preventDefault();
            log("\ntouchend/touchleave.");
            var touches = evt.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                var idx = ongoingTouchIndexById(touches[i].identifier);
                if (idx >= 0) {
                    // graphics.endFill();
                    ongoingTouches.splice(idx, 1);  // remove it; we're done
                } else {
                }
            }
        }
        //处理触摸对出事件
        function handleCancel(evt) {
            evt.preventDefault();
            log("\ntouchcancel.");
            var touches = evt.changedTouches;
            for (var i = 0; i < touches.length; i++) {
                ongoingTouches.splice(i, 1);  // remove it; we're done
            }
        }
        //拷贝一个触摸对象
        function copyTouch(touch) {
            return { identifier: touch.identifier, pageX: touch.pageX, pageY: touch.pageY };
        }
        //找出正在进行的触摸
        function ongoingTouchIndexById(idToFind) {
            for (var i = 0; i < ongoingTouches.length; i++) {
                var id = ongoingTouches[i].identifier;
                if (id == idToFind) {
                    return i;
                }
            }
            return -1;    // not found
        }
        //记录日志
        function log(msg, i = 0) {
            var p = document.getElementById('log');
            if (p.innerHTML.indexOf('\n') == 0 || (i && p.innerHTML.indexOf('\n') <= 50)) {
                p.innerHTML = msg + p.innerHTML;
            }
            else {
                p.innerHTML = msg + "\n" + p.innerHTML;
            }
        }
        log = function () { }
        function pointInsideCircle(pointX, pointY, circle) {
            if (circle.r === 0) return false;
            var dx = circle.x - pointX;
            var dy = circle.y - pointY;
            return dx * dx + dy * dy <= circle.r * circle.r;
        }
        function pointInsideSpuare(pointX, pointY, spuare_site) {
            return pointX >= spuare_site.x1 && pointX <= spuare_site.x2 && pointY >= spuare_site.y1 && pointY <= spuare_site.y2;
        }
        function inline(pointX, pointY) {
            if (pointY > _width) {
                return pointInsideSpuare(pointX, pointY, spuare_site1) && !pointInsideSpuare(pointX, pointY, spuare_site2)
            }
            else {
                return pointInsideCircle(pointX, pointY, circle_site1) && !pointInsideCircle(pointX, pointY, circle_site2)
            }
        }
        var inline_tick = 0;
        function inline_function(pointX, pointY) {
            if (inline_tick++ % 1 == 0) {
                if (!inline(pointX, pointY)) {
                    if (color >= 0x000000) {
                        // color -= 0x010101;
                        // color -= 1;
                        color = 0x000000;
                        // graphics.lineStyle(5, color);
                        refresh.beginFill(color);
                        refresh.drawRect(_width - 10, 10, 24, 24);
                        refresh.endFill();
                    }
                } else {
                    if (color <= 0xffffff) {
                        // color += 0x010101;
                        // color += 10;
                        color = 0xffffff;
                        // graphics.lineStyle(5, color);
                        refresh.beginFill(color);
                        refresh.drawRect(_width - 10, 10, 24, 24);
                        refresh.endFill();
                    }
                }
            }
        }
    </script>
</body>

</html>